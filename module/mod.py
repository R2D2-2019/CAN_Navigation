from client.comm import BaseComm
from common.frame_enum import FrameType
from common.frames import FramePathStep
from common.frames import FrameMapInfo
from common.frames import FrameMapObstacle
from common.frames import FrameRequestMapObstacles

from .Algorithms import AStar
from .Structure import Grid
from .Structure import grid_factory

# TODO: documentation
# TODO: Unit tests


class NavigationModule:
    """
    this class is based on the module template and implements the 3 template functions
    and additional functions that are needed.
    """

    def __init__(self, comm: BaseComm):
        """ The constructor
        :param comm: variable that serves as an interface to the CAN bus
        We tell the comm to listen for 
        """
        self.comm = comm
        self.path_id = 0
        self.map_info = None
        self.grid = Grid(0, 0)
        self.obstacles = list()
        self.requested = False
        self.algo = AStar(self.grid)
        self.comm.listen_for([FrameType.MAP_INFO, FrameType.MAP_OBSTACLE])
        # There's no way to listen for multiple specific types right now so we listen for all and filter

    def process(self):
        """ This function is what gets and puts data from/on the CAN bus """
        while self.comm.has_data():
            frame = self.comm.get_data()

            # I don't believe this is how requests are supposed to be used
            # but we'll do this for now until there's a proper way to request
            # TODO: get begin and end from request frame
            if frame.request:
                # when we receive a path request we request the obstacles from the database
                request_obstacles = FrameRequestMapObstacles()
                request_obstacles.set_data(self.path_id)
                self.comm.send(request_obstacles)
                self.path_id += 1
                self.requested = True

            # if a path was just requested we filter out mapinfo and obstacle frames
            if self.requested:
                if frame.type is FrameType.MAP_INFO and self.map_info is None:
                    self.process_map_frame(frame)
                elif frame.type is FrameType.MAP_OBSTACLE:
                    self.process_obstacle_frame(frame)

    def stop(self):
        """ This function is called when we stop the application """
        self.comm.stop()

    def process_request(self):
        if self.ready_check():
            map_data = self.map_info.get_data()
            self.grid = Grid(map_data[1], map_data[2])
            self.mark_obstacles_in_grid()
            # TODO: set start,end of algo to request frame start,end
            self.algo.solve()
            path = self.generate_frame_path(self.algo.path)

    def ready_check(self):
        # TODO: docs
        if self.map_info is not None and len(self.obstacles) == self.map_info.get_data()[0]:
            return True
        return False

    def process_map_frame(self, frame):
        # TODO: docs
        map_data = frame.get_data()
        self.map_info = FrameMapInfo()
        self.map_info.set_data(
            map_data[0], map_data[1], map_data[2], map_data[3], map_data[4])

    def process_obstacle_frame(self, frame):
        # TODO: docs
        obstacle_data = frame.get_data()
        obstacle = FrameMapObstacle()
        obstacle.set_data(obstacle_data[0], obstacle_data[1], obstacle_data[2])
        self.obstacles.append(obstacle)

    def generate_frame_path(self, path):
        """
        This function converts a path (list of coordinates) to a list of "frames".
        :param path: list of xy coordinates generated by the A-star class
        :return: returns a list of frames that acts as a path.
        """
        frame_path = list()
        step_id = 0

        for coord in path:
            frame = FramePathStep()
            frame.set_data(coord[0], coord[1], step_id, self.path_id)
            step_id += 1
            frame_path.append(frame)

        self.path_id += 1
        return frame_path

    def mark_obstacles_in_grid(self):
        # TODO: docs
        for obstacle in self.obstacles:
            x, y = obstacle[0], obstacle[1]
            self.grid[(x, y)].accessible = False
